language ESSENCE' 1.0

$ given v, b, r, k, lambda : int(1..)
 
$ the following conditions define a symmetric BIBD:
$ where v = b
$ where r = k
 
$ the following conditions are necessary for solutions to exist, see ../results/
$ where r * v = b * k
$ where lambda * (v - 1) = r * (k - 1)
$ where b >= v
 
$ letting Obj   be new type of size v,
$         Block be new type of size b
 
$ find bibd : relation of (Obj * Block)
 
$ such that
$     forAll o  : Obj   . |toSet(bibd(o,_ ))| = r,
$     forAll bl : Block . |toSet(bibd(_,bl))| = k,
$     forAll o1, o2 : Obj
$         , o2 != o1
$         . |toSet(bibd(o1,_)) intersect toSet(bibd(o2,_))| = lambda

letting v be 9
letting b be 12
letting r be 4
letting k be 3
letting l be 1

find  bibd: matrix indexed by [int(1..v), int(1..b)] of int(0..1)

such that
  $ each block contains k different objects 
  forAll block : int(1..b) .
    (sum object : int(1..v) .  bibd[object, block]) =  k,

  $ each object occurs in r blocks
  forAll object : int(1..v) .
    (sum block : int(1..b) . bibd[object, block]) = r,

  $ two different objects occurr in a block exactly l times
  forAll object1 : int(1..v) .
    forAll object2 : int(1..v) .
      (object1 < object2) ->  
      ((sum block : int(1..b) .
        bibd[object1,block] * bibd[object2, block]) = l),

  $ Some symmetry breaking constraints
  forAll row: int(1..8) . $ v - 1
    bibd[row,..] <=lex bibd[row+1,..],

  forAll col: int(1..11) . $ b - 1
    bibd[..,col] <=lex bibd[..,col+1]
